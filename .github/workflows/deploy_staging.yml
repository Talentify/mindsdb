# This workflow will build and push a new container image to Amazon ECR,
# and then will deploy it to kubernetes.

name: Deploy Staging

on:
  workflow_dispatch:
    inputs:

env:
  # AWS credentials
  AWS_GIT_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_GIT_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: us-east-1
  # For clonning private composer dependencies
  COMPOSER_AUTH: '{"github-oauth": { "github.com": "${{ secrets.GIT_COMPOSER_AUTH }}" } }'
  # Kubernetes
  PROJECT_NAME: mktplace
  KUBE_EKS_CLUSTER: programmatic-ad-staging-cluster
  #
  CONTAINER_REPOSITORY_URI: "124082513016.dkr.ecr.us-east-1.amazonaws.com/mktplace"
  ENVIRONMENT: staging

jobs:
  #########################################
  #####      Deploy Staging       ######
  #########################################
  deploy-staging:
    ## For use in Staging deploy
    # if: github.ref == 'refs/heads/main'
    name: Deploy to Staging
    runs-on: ubuntu-latest
    # Define the environment that the job references.
    # A deployment will be used by GitHub in some parts of its user interface.
    # Also, one can use a deployment to specify protection rules on GitHub.
    # reference: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenvironment
    environment:
      name: staging
      url: http://api.tflux.internal/mktplace
    # Custom environment variables
    # reference: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idenv
    env:
      # Variables need be change on each environment
      ENVIRONMENT: staging
      KUBE_EKS_CLUSTER: programmatic-ad-staging-cluster
      K8S_NAMESPACE: mktplace

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Python version
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          mask-aws-account-id: "true"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: "true"

      # references:
      # https://docs.github.com/en/actions/learn-github-actions/environment-variables#passing-values-between-steps-and-jobs-in-a-workflow
      # https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context
      - name: Generate new APP_VERSION and publish release
        id: generate_app_version
        run: |
          APP_VERSION="$(date +'%Y-%m-%d_%H%M%S')"
          APP_LATEST_IMAGE_VERSION="${APP_VERSION}"
          MIGRATION_JOB_NAME=$(echo $APP_LATEST_IMAGE_VERSION | sed s/_/-/g)
          echo "MIGRATION_JOB_NAME=${MIGRATION_JOB_NAME}" >> $GITHUB_ENV
          echo "APP_VERSION=${APP_VERSION}" >> $GITHUB_ENV
          echo "APP_LATEST_IMAGE_VERSION=${APP_LATEST_IMAGE_VERSION}" >> $GITHUB_ENV
          echo GIT_LAST_COMMIT_MESSAGE=\"$(git log -n 1 --format=%s)\" >> $GITHUB_ENV
        env:
          TZ: America/Sao_Paulo

      - name: Log in K8S
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ env.KUBE_EKS_CLUSTER }}

      #|
      #| Update secret APP_VERSION
      #|
      - name: "[${{ env.ENVIRONMENT }}] mktplace: update Secret 'APP_VERSION'"
        env:
          K8S_NAMESPACE: mktplace
        run: |
          kubectl patch secret -n mktplace mktplace-all -p="{\"data\":{\"APP_VERSION\":\"$(echo -n $APP_VERSION | base64)\"}}"

      # #|
      # #| Build main image
      # #|
      - name: Build and push - mktplace base
        uses: docker/build-push-action@v6
        with:
          target: web-base
          context: .
          file: var/docker/Dockerfile
          push: true
          build-args: |
            APP_VERSION=${{ env.APP_VERSION }}
            GH_AUTH=${{ secrets.GIT_COMPOSER_AUTH }}
          tags: |
            ${{ env.CONTAINER_REPOSITORY_URI }}:web-staging-${{ env.APP_LATEST_IMAGE_VERSION }}
            ${{ env.CONTAINER_REPOSITORY_URI }}:web-staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max


# -----------------------------------------------------------------------------------------
# Modo 1
      - name: Instalar Trivy via curl
        shell: bash
        run: |
          curl -sfL curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin v0.60.0
          trivy --version

      - name: Verificar vulnerabilidades nas dependências do repositório (SBOM)
        shell: bash
        run: |
          trivy repo --scanners vuln,secret,license,config,misconfig --severity CRITICAL,HIGH --format table --table-mode summary .

      - name: Verificar vulnerabilidades no código-fonte
        shell: bash
        run: |
          trivy fs --scanners vuln,secret,license,config,misconfig --severity CRITICAL,HIGH --format table --table-mode summary -o trivy-report-summary .

      - name: Scan a local code repository, for vulnerabilities, exposed secrets and misconfigurations
        shell: bash
        run: |
          trivy fs --severity CRITICAL,HIGH --scanners vuln,secret,license,config,misconfig --format table -o trivy-report .

      - name: Verificar vulnerabilidades no Dockerfile
        shell: bash
        run: |
          trivy config --severity CRITICAL,HIGH ./var/docker/Dockerfile

      - name: Verificar vulnerabilidades na imagem Docker
        shell: bash
        run: |
          trivy image --severity CRITICAL,HIGH --exit-code 0 ${{ env.CONTAINER_REPOSITORY_URI }}:web-${{ env.ENVIRONMENT }}-${{ env.APP_LATEST_IMAGE_VERSION }}

      # 5. Upload o artefato do relatório
      - name: Upload Trivy report as artifact
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-report
          retention-days: 1

      # 6. Exibir o resumo do relatório no Summary
      - name: Add Trivy report to Summary
        run: |
          ls
          echo "### Trivy Security Report" >> $GITHUB_STEP_SUMMARY
          echo "#### Summary of vulnerabilities found" >> $GITHUB_STEP_SUMMARY
          cat trivy-report-summary >> $GITHUB_STEP_SUMMARY

# -----------------------------------------------------------------------------------------
# Modo 2
      - name: Instalar e rodar Trivy para código-fonte (IaC, dependências)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'  # Verifica código-fonte
          scan-ref: '.'  # Diretório atual
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
          format: 'table'

# Trivy vulnerability scanner
      - name: Verificar vulnerabilidades na imagem Docker
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'image'
          image-ref: '${{ env.CONTAINER_REPOSITORY_URI }}:web-${{ env.ENVIRONMENT }}-${{ env.APP_LATEST_IMAGE_VERSION }}'
          format: 'table'
          exit-code: '0'  # Não falhará se encontrar vulnerabilidades
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

# Trivy vulnerability scanner
      - name: Verificar dependências do repositório (SBOM)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'repo'
          scan-ref: '.'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
          format: 'table'

# Trivy vulnerability scanner

      - name: Gerar Relatório JSON
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
          format: 'json'
          output: 'trivy-report.json'

      - name: Upload do Relatório JSON
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-report
          path: trivy-report.json
          retention-days: 1

#########################################################################################

      #| Create release
      - run: npm install axios
      - uses: actions/github-script@v6
        name: "Create release"
        with:
          script: |
            const script = require('./.github/workflows/create_release.js')
            await script({github, context})
        env:
          # https://app.shortcut.com/talentify/story/40035
          SHORTCUT_API_TOKEN: ${{ secrets.SHORTCUT_API_TOKEN }}

      #|
      #| Namespace: web / migrations
      #|
      - name: "[staging] migrations: update and run migrations job"
        env:
          K8S_NAMESPACE: mktplace
        run: |
          sed -i 's/MIGRATION_JOB_NAME/${{ env.MIGRATION_JOB_NAME }}/g' ./var/kubernetes/staging/web/migrations.yaml
          sed -i 's/WEB_TAG_TEMPLATE/web-staging-${{ env.APP_LATEST_IMAGE_VERSION }}/g' ./var/kubernetes/staging/web/migrations.yaml
          kubectl apply -f ./var/kubernetes/staging/web/migrations.yaml -n ${{ env.K8S_NAMESPACE }}
          sleep 5
        #  kubectl wait --for=condition=complete --timeout=3600s job/mktplace-migrations-${{ env.MIGRATION_JOB_NAME }} -n ${{ env.K8S_NAMESPACE }}
        # please, note that the k8s job also has a timeout defined by "ttlSecondsAfterFinished"

      - name: Wait for Job migrations complete
        id: wait-migrations
        if: ${{ always() }}
        run: |
          while true; do
            STATUS=$(kubectl get job mktplace-migrations-${{ env.MIGRATION_JOB_NAME }} -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
            if [ "$STATUS" == "True" ]; then
              echo "Job succeeded"
              break
            fi
            STATUS=$(kubectl get job mktplace-migrations-${{ env.MIGRATION_JOB_NAME }} -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Failed")].status}')
            if [ "$STATUS" == "True" ]; then
              echo "Job failed"
              break
            fi
            echo "Waiting for job to complete..."
            sleep 2
          done

      - name: Get migrations Pod Names
        if: ${{ always() }}
        id: get-pod-names
        run: |
          POD_NAMES=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l job-name=mktplace-migrations-${{ env.MIGRATION_JOB_NAME }} -o jsonpath='{.items[*].metadata.name}')
          echo "POD_NAMES=${POD_NAMES}" >> $GITHUB_ENV

      - name: Save Migrations Logs
        if: ${{ always() }}
        id: check-status
        run: |
          STATUS=$(kubectl get job mktplace-migrations-${{ env.MIGRATION_JOB_NAME }} -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}')
          PODS=(${{ env.POD_NAMES }})
          for POD in "${PODS[@]}"; do
            echo "========== log pod: $POD =============" >> "mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}.txt"
            kubectl logs pod/$POD -n ${{ env.K8S_NAMESPACE }} >> "mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}.txt"
            echo "==========================================" >> "mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}.txt"
          done
          if [ "$STATUS" != "True" ]; then
            echo "Job failed"
            exit 1
          fi
          echo "Job succeeded"

      - name: Show Migrations Logs
        if: ${{ always() }}
        run: |
          cat mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}.txt

      - name: Upload Migrations Logs Artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}
          path: mktplace-migrations-${{ env.MIGRATION_JOB_NAME }}.txt
          retention-days: 1

      #|
      #| Namespace: cronjob
      #|

      # ## Nesse método estou dando apply em todo o diretório /cronjob logo se adicionar um arquivo novo ele será adicionado no próximo deploy
      # - name: "[${{ env.ENVIRONMENT }}] cronjob: update configurations for cronjobs"
      #   id: deployment
      #   env:
      #     K8S_NAMESPACE: mktplace
      #   run: |
      #     FILES=$(cd var/kubernetes/${{ env.ENVIRONMENT }}/cronjob && ls *.yaml)
      #     for pod_name in $FILES; do
      #       echo "Updating CronJob $pod_name"
      #       sed -i 's/WEB_TAG_TEMPLATE/web-${{ env.ENVIRONMENT }}-${{ env.APP_LATEST_IMAGE_VERSION }}/g' ./var/kubernetes/${{ env.ENVIRONMENT }}/cronjob/$pod_name
      #       kubectl apply -f ./var/kubernetes/${{ env.ENVIRONMENT }}/cronjob/$pod_name -n ${{ env.K8S_NAMESPACE }}
      #     done

      #|
      #| Deploy web
      #|
      - name: "[${{ env.ENVIRONMENT }}] web: update image for workload 'mktplace-web', container 'mktplace-web'."
        id: deployment
        env:
          K8S_NAMESPACE: mktplace
        run: |
          sed -i 's/WEB_TAG_TEMPLATE/web-${{ env.ENVIRONMENT }}-${{ env.APP_LATEST_IMAGE_VERSION }}/g' ./var/kubernetes/${{ env.ENVIRONMENT }}/web/deployment.yaml
          kubectl config use-context arn:aws:eks:us-east-1:124082513016:cluster/${{ env.KUBE_EKS_CLUSTER }}
          kubectl apply -f ./var/kubernetes/${{ env.ENVIRONMENT }}/web/deployment.yaml -n ${{ env.K8S_NAMESPACE }}

      - uses: actions/checkout@v4
      - name: Create Sentry release
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ env.PROJECT_NAME }}
        with:
          environment: staging
          version: ${{ env.APP_VERSION }}

      - name: Status
        id: status
        if: ${{ always() }}
        env:
          BLOCK_FAILURE: ff2500
          BLOCK_SUCCESS: 2b8a3e
        run: |
          if [[ "${{ steps.deployment.outcome }}" != 'success' ]]; then
            echo ${{ steps.deployment.outcome }}
            echo "flag=${{ steps.deployment.outcome }} :red_circle:" >> $GITHUB_OUTPUT
            echo "block=${{ env.BLOCK_FAILURE }}" >> $GITHUB_OUTPUT
          else
            echo ${{ steps.deployment.outcome }}
            echo "flag=${{ steps.deployment.outcome }} :large_green_circle:" >> $GITHUB_OUTPUT
            echo "block=${{ env.BLOCK_SUCCESS }}" >> $GITHUB_OUTPUT
          fi

      #|
      #| Notify
      #|
      # reference: https://github.com/slackapi/slack-github-action#technique-3-slack-incoming-webhook
      # Create your app or use mine: https://api.slack.com/apps/A037R2Q23RQ
      # Copy the "Webhook URL" and then add it in GitHub secret called "SLACK_WEBHOOK_URL".
      - name: Notify about the new deployment
        id: slack
        if: ${{ always() }}
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: incoming-webhook
          # For posting a rich message using Block Kit
          payload: |
            {
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.block }}",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "Deploy - ${{ env.PROJECT_NAME }} - env: ${{ env.ENVIRONMENT }} - Created by: ${{ github.actor }}",
                        "emoji": true
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": "*Status:* ${{ steps.status.outputs.flag }} - *Version:* <${{ env.RELEASE_URL }}|${{ env.APP_VERSION }}> - *Branch:* <${{ github.server_url }}/${{ github.repository }}/tree/${{ github.ref_name }}|${{ github.ref_name }}>"
                      }
                    }
                  ]
                }
              ]
            }
        env:
          RELEASE_URL: ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ env.APP_VERSION }}
